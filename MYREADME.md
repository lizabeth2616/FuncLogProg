# Fox

Функциональный язык программирования с ленивыми вычислениями, реализованный на F#.

## Особенности языка

- Поддержка ленивых вычислений (lazy/force)
- Функциональный подход с каррированием
- Статическая типизация с выводом типов
- Сопоставление с образцом
- Встроенные структуры данных: кортежи, списки
- Модульная система (импорт других файлов)

## Сборка

Весь проект написан на платформе .NET версии .NET 6.0. Для сборки проекта необходимо:

1. Установить .NET SDK с поддержкой версии .NET 6.0
2. Выполнить команды в терминале:

```bash
# Сборка проекта
dotnet build
```

```bash
# Запуск программы
dotnet run -- <путь_к_файлу.lf>
```

```bash
# Пример:
dotnet run -- examples/factorial.lf
```

## Документация

### Структура программ в Fox

Программы на языке Fox состоят из последовательности выражений, которые выполняются по порядку. Каждое выражение должно заканчиваться точкой с запятой `;`. Минимальная программа содержит хотя бы одно выражение.

**Основные правила:**
- Файлы сохраняются с расширением `.lf` (например, `program.lf`)
- Выражения выполняются сверху вниз
- Импорт других файлов через `import`

### Пример программы

```fox
// Пример программы с импортом и вычислениями
import math;  // Подключение стандартной библиотеки
 
let x = 5;    // Объявление переменной 
let y = x * 2;  
 
io.print(y);  // Вывод: 10
```

### Импорт модулей

Программы могут вызывать программы из других файлов с помощью конструкции `import`. Пример:

```fox
import les;  // Сначала ищет стандартный модуль 'les',  
             // затем файл les.lf в текущей директории
```

**Алгоритм работы import:**
1. Поиск в стандартных библиотеках (встроенный модуль "les")
2. Поиск в файловой системе (файл "les.lf" в текущей директории)
3. Выполнение программы из найденного файла
   - Все объявленные идентификаторы становятся доступными
   - Импорт выполняется только один раз

### Применение функций и операторов

Fox — строго функциональный язык, где все вычисления выполняются через вызов функций и применение операторов.

**Синтаксис вызова функций:**
```fox
{func arg1 arg2 ... argN}
```
где:
- `func` — имя функции
- `arg1...argN` — аргументы (через пробел)

Примеры:
```fox
{square 5}     // 25 
{sum 10 20}    // 30 
{print "Hello"} // Вывод в консоль
```

**Операторы:**
Доступные операторы (являются функциями с именами из специальных символов):
`+`, `-`, `*`, `/`, `=`, `>`, `<`, `&`, `|`, `!`, `~`

Примеры:
```fox
{+ 3 5}    // 8 
{* 2 4}    // 8 
{= 10 10}  // true 
{> 7 2}    // true
```

## Конструкции `let` и `let-in`

### 1. Основной синтаксис `let`
Связывает имя с выражением или функцией:
```fox
let <имя> [<аргументы>] = <выражение>;
```

**Без аргументов** (создает константу):
```fox
let pi = 3.1415;
```

**С аргументами** (создает функцию):
```fox
let square x = {* x x};  // Функция возведения в квадрат
```

### 2. Каррирование
Все функции автоматически каррируются:
```fox
let add = {+ 5};
add 10  // 15
```

Можно объявить оператор - для этого надо использовать в имени оператора только особые символы. После того, как мы прописали конструкцию let, она создает именованную переменную, которая будет жить всё оставшееся время программы. 

Пример. Можно определять свои операторы (символы: + - * / = > < & | !): 
```fox
let !@ x y = {+ {* x 2} y};  // Пользовательский оператор
{!@ 3 4};                    // 10 (3*2 + 4)
```

### 3. Локальные переменные (`let-in`)
Создает временное связывание, видимое только в expr2:
```fox
let <имя> = <expr1> in <expr2>;
```

**Пример**:
```fox
let x = 5 in
  {+ x 10};  // 15
// x здесь уже недоступен
```

### 4. Сравнение `let` и `let-in`
| Конструкция | Область видимости | Использование          |
|-------------|-------------------|------------------------|
| `let`       | Глобальная        | Для функций/констант   |
| `let-in`    | Локальная         | Для временных вычислений |

## Базовые типы

### 1. Числовые типы
| Тип   | Описание                     | Примеры      |
|-------|------------------------------|-------------|
| `int` | 32-битное целое число        | 42, -7, 0   |
| `float` | 64-битное число с плавающей точкой | 3.14, -0.5 |

**Пример**:
```fox
let age = 25;
let pi = 3.1415;
```

### 2. Строки и литералы
| Тип      | Описание                          | Примеры         |
|----------|-----------------------------------|----------------|
| `string` | Текст в двойных кавычках          | "Hello"        |
| `literal` | Строка без пробелов (начинается с %) | %nl, %debug_mode |

**Пример**:
```fox
let greeting = "Hello, world!";
let newline = %nl;  // Символ перевода строки
```

### 3. Логический тип и None
| Тип   | Описание          | Примеры    |
|-------|-------------------|-----------|
| `bool` | Логические значения | true, false |
| `none` | Пустое значение   | None      |

**Пример**:
```fox
let is_valid = true;
let empty_value = None;
```

### 4. Кортежи (tuples)
```fox
(1, "apple", true);          // Кортеж из 3 элементов
(3.14, ("nested", None));    // Вложенные кортежи
```

### 5. Лямбда-функции
```fox
let increment = \x -> {+ x 1};          // Функция +1
let add = \x -> \y -> {+ x y};          // Каррированное сложение
let sum = {add 5 3};                    // 8
```

**Пример**:
```fox
let numbers = [1, 2, 3];
let squared = list.map (\x -> {* x x}) numbers;  // [1, 4, 9]
```

## Типы и ограничения типов
Позволяют задавать требования к типам аргументов и возвращаемых значений. 

**Синтаксис:**
```fox
type <ИмяОграничения> = <ШаблонТипа>;
```

**Ключевые конструкции:** 

 - choice — объединение типов ("или") 

 - _ — любой тип 

 - Вложенность ограничений 

**Примеры**:
```fox
type IntOrString = choice int | string;  // Целое ИЛИ строка
type Vec2 = (float, float);              // Кортеж из 2 float
type Matrix = (Vec2, Vec2);              // Вложенное ограничение
type AnyTuple3 = (_, _, _);              // Кортеж из 3 любых значений
```

## Сопоставление с образцом
Проверяет значение на соответствие шаблонам. 

**Синтаксис:**
```fox
match <выражение> with
| <образец1> -> <результат1>
| <образец2> -> <результат2>
...
| _ -> <результат по умолчанию> $;
```

**Особенности:**
 - of — проверка типа (использует ограничения)
 - _ — wildcard (любое значение)
 - $ — конец конструкции 

**Пример**:
```fox
let check_type x = match x with
  | _ of int -> "Целое число"
  | _ of (float, float) -> "Вектор"
  | (_, y of string) -> "Кортеж со строкой"
  | _ -> "Неизвестный тип" $;
```

## Внутренние функции

В языке программирования, помимо стандартных функций и операторов, которые представляют собой выражения для вычисления значений переменных, существуют также "внутренние" функции и операторы. Это особый тип выражений, внутри которых находится F#-функция, принимающая список выражений и возвращающая новое выражение.

В отличие от обычных функций, внутренние нельзя определить непосредственно в коде на языке Fox — их реализация возможна только на F# и включается в программу через внешние библиотеки.

Ключевое отличие внутренних функций и операторов от обычных заключается в их поведении при вызове: они не поддерживают каррирование. Вместо этого при применении они получают все аргументы сразу в виде списка.

### Отличия от обычных функций:

**Не каррируются:**
```fox
{internal_func arg1 arg2}  // Все аргументы передаются сразу списком
```

**Определяются только в коде на F#:**
```fsharp
// Пример регистрации внутренней функции
let addImpl args = 
    match args with
    | [Int a; Int b] -> Int(a + b)
    | _ -> failwith "Ошибка типов"
```

**Использование:**
```fox
d{+ 2 3}  // Внутренний оператор (аналогично функциям)
```

## Стандартная библиотека
Стандартная библиотека автоматически подключается ко всем исходным файлам (.lf) и предоставляет базовые функции и операторы для работы с типами данных. 

### 1. Основные операторы
| Оператор | Описание           | Пример         |
|----------|--------------------|---------------|
| `+ - * /` | Арифметические     | `{+ 2 3} → 5` |
| `< > <= >=` | Сравнения         | `{> 5 3} → true` |
| `= !=`    | Проверка равенства | `{= "a" "a"} → true` |

### 2. Базовые функции
**Математические**:
```fox
{std.mod 10 3}    // 1 (остаток от деления)
{std.abs -5}      // 5 (модуль числа)
```

**Работа с типами**:
```fox
{std.match_type x int}           // true/false
{std.match_type (1, "a") (int, string)}  // true
```

**Ввод-вывод**:
```fox
{std.print "Text:" (1, 2) %nl}  // Вывод: "Text: (1, 2)\n"
let input = {std.read_line}      // Чтение строки
```

## Примеры программ

### Факториал с проверкой ввода
```fox
let rec fact n = if {= n 0} then 1 else {* n {fact {- n 1}}}};

{std.print "Enter number:"};
let n = {std.parse {std.read_line}};

if {std.match_type n int} then
     {std.print {fact n} %nl}
else
     {std.print "Error: expected int!" %nl};
```

### Работа со списками
```fox
let even = list.filter {std.mod _ 2 == 0} [1, 2, 3, 4];
{std.print even};  // [2, 4]
```

### Композиция функций
```fox
let addTwo = {+ 2};
let square = {* _ _};
{(addTwo >> square) 3}  // (3+2)² = 25
```

**Больше примеров** - в папке `examples`.


>В данной работе я использовала ИИ для получения необходимой информации для написания своего языка программирования. Благодаря ИИ мне удалось получить исчерпывающие сведения для реализации данной курсовой работы, что позволило сэкономить время на поиске и анализе информации из множества источников.

>Автор курсового проекта: Жданович Елизавета (М8О-207Б-23)
